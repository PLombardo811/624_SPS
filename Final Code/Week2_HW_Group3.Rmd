---
title: "624_HW2_Group3""
output: html_document
---
```{r}
library(readxl)
library(ggplot2)
library(forecast)
library(fpp2)
```
#6.2 The plastics data set consists of the monthly sales (in thousands) of product A for a plastics manufacturer for five years.
##A Plot the time series of sales of product A. Can you identify seasonal fluctuations and/or a trend-cycle?
```{r}
autoplot(plastics)
```
##The plot of the data shows that there are seasonal fluctuations and upward trend.

##B Use a classical multiplicative decomposition to calculate the trend-cycle and seasonal indices.

```{r}
decompose_plastics <- decompose(plastics,
                                type = "multiplicative")
autoplot(decompose_plastics)
```
##C Do the results support the graphical interpretation from part a?

Yes, the plot does show an upward trend and presence of the seasonal fluctuations.

##D Compute and plot the seasonally adjusted data.
```{r}
autoplot(plastics, series="Data") +
  autolayer(trendcycle(decompose_plastics), series="Trend") +
  autolayer(seasadj(decompose_plastics), series="Seasonal Data") +
  xlab("Year") + ylab("Monthly Sales") +
  ggtitle("Sales of plastic products") +
  scale_colour_manual(values=c("gray","blue","black"),
                     breaks=c("Data","Seasonal Data","Trend"))
```
##E Change one observation to be an outlier (e.g., add 500 to one observation), and recompute the seasonally adjusted data. What is the effect of the outlier? 
```{r}
plastics_outlier  <- plastics
plastics_outlier [50] <- plastics_outlier [50] + 500
decompose_plastics_outlier<- decompose(
  plastics_outlier,
  type = "multiplicative"
  )
autoplot(plastics_outlier, series="Data") +
  autolayer(trendcycle(decompose_plastics_outlier), series="Trend") +
  autolayer(seasadj(decompose_plastics_outlier), series="Seasonal Data") +
  xlab("Year") + ylab("Monthly Sales") +
  ggtitle("Sales of plastic products") +
  scale_colour_manual(values=c("gray","blue","black"),
                     breaks=c("Data","Seasonal Data","Trend"))
```
##The outlier affects trend little, but affects the seasonally adjusted data severely. Seasonally adjusted data have errors like the original data have.


##F Does it make any difference if the outlier is near the end rather than in the middle of the time series?
```{r}
plastics_outlier2  <- plastics
plastics_outlier2 [10] <- plastics_outlier2 [10] + 500
decompose_plastics_outlier2<- decompose(
  plastics_outlier2,
  type = "multiplicative"
  )
autoplot(plastics_outlier2, series="Data") +
  autolayer(trendcycle(decompose_plastics_outlier2), series="Trend") +
  autolayer(seasadj(decompose_plastics_outlier2), series="Seasonal Data") +
  xlab("Year") + ylab("Monthly Sales") +
  ggtitle("Sales of plastic products") +
  scale_colour_manual(values=c("gray","blue","black"),
                     breaks=c("Data","Seasonal Data","Trend"))
```
##If an outlier is near the end, the effect to trend decreases.


#6.6 We will use the bricksq data (Australian quarterly clay brick production. 1956–1994) for this exercise.
##A Use an STL decomposition to calculate the trend-cycle and seasonal indices. (Experiment with having fixed or changing seasonality.)
```{r}
# STL decomposition fixed seasonality
fixed_stl <- stl(bricksq, 
                          s.window = "periodic",
                          robust = TRUE)
# STL decomposition changing seasonality
changing_stl <- stl(bricksq,
                             s.window = 8,
                             robust = TRUE)
```
```{r}
#Plot Data
autoplot(fixed_stl) +
  ggtitle('Brick STL Fixed')
autoplot(changing_stl) +
  ggtitle('Brick STL Changing')
```
##B Compute and plot the seasonally adjusted data.
```{r}
# fixed seasonality
autoplot(bricksq, series = 'Data') +
  autolayer(seasadj(fixed_stl),
            series = 'Seasonal Data') +
  autolayer(trendcycle(fixed_stl),
            series = 'Trend cycle') +
  ggtitle('Australian quarterly clay brick production. 1956-1994',
          subtitle = 'decomposed using STL with fixed seasonality') +
  scale_color_manual(values = c('gray', 'blue', ' black'),
                     breaks = c('Data', 'Seasonal Data','Trend cycle'))
# changing seasonality
autoplot(bricksq, series = 'Data') +
  autolayer(seasadj(changing_stl),
            series = 'Seasonal Data') +
  autolayer(trendcycle(changing_stl),
            series = 'Trend cycle') +
  ggtitle('Australian quarterly clay brick production. 1956-1994',
          subtitle = 'decomposed using STL with changing seasonality') +
  scale_color_manual(values = c('gray', 'blue', ' black'),
                     breaks = c('Data', 'Seasonal Data','Trend cycle'))
```
##C Use a naïve method to produce forecasts of the seasonally adjusted data.
```{r}
fixed_stl %>% seasadj() %>% naive() %>% autoplot() + 
  ggtitle(label = "Naive forecast for seasonally adjusted brick data",
          subtitle = "decomposed using STL with fixed seasonality")
changing_stl %>% seasadj() %>% naive() %>% autoplot() + 
  ggtitle(label = "Naive forecast for seasonally adjusted brick data",
          subtitle = "decomposed using STL with changing seasonality")
```
#the prediction intervals of seasonally adjusted data decomposed by STL have smaller ranges than the fixed seasonality. This is because the variance of the remainder component decreased when the seasonality is changed.


##D Use stlf() to reseasonalise the results, giving forecasts for the original data.
```{r}
stlf_brick <- stlf(bricksq)
autoplot(stlf_brick)
```
##E Do the residuals look uncorrelated? 
```{r}
checkresiduals(stlf_brick)
```
##The residuals appear to be correlated with each other.

##F Repeat with a robust STL decomposition. Does it make much difference?
```{r}
stlf_brick_robust <- stlf(bricksq, robust = TRUE)
autoplot(stlf_brick_robust)
checkresiduals(stlf_brick_robust)
```
##The autocorrelation lowered in general, but there are still some high value outliers.

##G Compare forecasts from stlf() with those from snaive(), using a test set comprising the last 2 years of data. Which is better?
```{r}
train_data <- subset(bricksq, 
                        end = length(bricksq) - 7)
test_data <- subset(bricksq,
                        start = length(bricksq) - 9)
snaive_brick <- snaive(train_data)
stlf_brick_part <- stlf(train_data, robust = TRUE)

autoplot(bricksq, series = "Original") +
  geom_line(size = 1) +
  autolayer(stlf_brick_part, PI = FALSE, size = 1,
            series = "stlf forecast") +
  autolayer(snaive_brick, PI = FALSE, size = 1,
            series = "snaive forecast") +
  scale_color_manual(values = c("gray", "blue", "green"),
                     breaks = c("Original", "stlf forecast", "snaive forecast")) +
  scale_x_continuous(limits = c(1990, 1994.5)) +
  scale_y_continuous(limits = c(350, 550)) +
  guides(colour = guide_legend(title = "Data")) +
  ggtitle("Forecast comparison between stlf and snaive functions") +
  annotate(
    "rect",
    xmin=1993,xmax=1994.5,ymin=-Inf,ymax=Inf,
    fill="light blue",alpha = 0.5
    )
```
##The forecasts from stlf function are more similar to the original data than the forecasts from snaive function. The stlf function trends, and its seasonality tend to change over a period time. Therefore stlf function was better than snaive function to predict brick production amounts for near future.

